/*
Sudoku Generator [2018.10]
This class is the solver. It uses backtracking to generate Sudoku puzzles. It
must be initialized with an integer passed which corresponds to the solver's
type--of which there are six. Then a puzzle can be generated by calling the
generateNewPuzzle() function, and the occupied board will be saved to the object
member "board". A formatted string containing the puzzle can be acquired with
puzzleToString().
As stated, there are six solver types, which are as follows:
    1 - Reversion
        This type, as well as types 3 to 6, operates on the original board array
        passed from generateNewPuzzle().
    2 - Copy
        This type does not touch previous iterations of the board array and
        instead makes a copy of the board in each solveCop() call.
    3 - Reversion 1 Row
        Initializes the board with 1 row randomized.
    4 - Reversion 1 Tile
        Initializes the board with 1 tile (3x3 segment) randomized.
    5 - Reversion 2 Tile
        Initializes the board with 2 tiles (3x3 segments) randomized.
    6 - Reversion 3 Tile
        Initializes the board with 3 tiles (3x3 segments) randomized.

Some averages were accumulated over 55000 generations of puzzles for each type,
cut into runs of 5000 generations:
| Type      | Time [s] | % Success |
| Reversion | 4.443865 |     64.28 |
| Copy      | 4.484913 |     63.87 |
| 1 Row     | 1.592783 |     64.25 |
| 1 Tile    | 1.604688 |     64.14 |
| 2 Tiles   | 1.148189 |     76.79 |
| 3 Tiles   | 0.898682 |     76.26 |
(In other words, the number of seconds it took to generate 5000 puzzles with the
given solver type and the percentage of proper generations of the 5000 puzzles)

The latter four types only differ in their style of initializing the board.
Due to the ease to code, I started with just the row initialized, which
unsurprisingly (and I would say pretty significantly) improves the execution
time. Then, testing with one tile preestablished. With that, it was trivial to
extend to two and three tiles. Also expectedly, the more the board is filled,
the faster the algorithm. Notably, the row does not have any further testing
because it is possible to randomly generate three tiles without having to
backtrack and with minimal impact on the success rate because tiles along the
diagonals do not directly intersect with one another, whereas doing it by rows
(and therefore by columns) often leads to conflicts.

I chose to keep an array corresponding to the board entries' potential
candidates, which is frequently referred to as "possiblities". It is an array of
81 uint16_t's, and the individual values are treated like a bit checklist; for
instance, 1011001, is a square that can potentially use 1, 4, 5, or 7, without
conflicting with any preexisting squares. An alternative to this would be to
re-compute potentials for squares, but it seemed nice to be able to have a bit
of foresight and fill squares in an order such that squares with few choices
are prioritized.
*/
#include "PuzzleGenerator.h"

#include <sstream>
#include <iostream> // delete later?

// CONSTRUCTORS
/*
Each puzzle generator requires an integer passed in, which determines the type
of solver used.
*/
PuzzleGenerator::PuzzleGenerator(int t)
    : type(t)
{
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        board[i] = 0;
    }
}

/*
Defaults to solver type 0, backtracking with reversion on an empty board
*/
PuzzleGenerator::PuzzleGenerator()
    : type(0)
{
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        board[i] = 0;
    }
}

// PUBLIC ENTRANCE TO PUZZLE GENERATOR
bool PuzzleGenerator::generateNewPuzzle()
{
    // Start out with a board and its possibilities
    uint8_t board[Constants::SIZE];
    uint16_t possibilities[Constants::SIZE];
    // inhabits the board as empty unless the type specifies otherwise
    initializeBoards(board, possibilities);

    // call the solve functions
    if (type != solverType::COPY)
    {
        return solveRev(board, possibilities);
    }
    else
    {
        return solveCop(board, possibilities);
    }
}

// SOLVE FUNCTIONS
/*
These two functions, solveRev and solveCop, with boards initialized as
completely empty, have comparable results. However, I don't know why exactly,
but the solver that copies a new board array every time was actually superior in
both speed and success rate compared to the one that simply reverts. Perhaps its
quickness has has to do with speeds of accessing the data/memory. As for the
success rate, I can't say. The reversion variant should use less memory and the
differences are minute, so the reversion variant is used in the other solvers.
| Type      | Time [s] | % Success |
| Reversion | 4.443865 |     64.28 |
| Copy      | 4.484913 |     63.87 |
*/

/*
This variation of the solve function makes a copy of the possibilities array,
but retains the original copy of the board. Before backtracking, changes are
reverted by resetting the selected "candidate position" to unassigned/empty.
*/
bool PuzzleGenerator::solveRev(uint8_t board[Constants::SIZE], const uint16_t possibilities[Constants::SIZE])
{
    // Make new possibilities array
    uint16_t newPoss[Constants::SIZE];
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        newPoss[i] = possibilities[i];
    }

    // Pick empty cell with fewest candidates
    int index = getEmptyIndex(board, newPoss);
    // no empty cells remaining means board is filled
    if (index == -1)
    {
        // Cool.
        for (int i = 0; i < Constants::SIZE; ++i)
        {
            this->board[i] = board[i];
        }
        return true;
    }

    while (newPoss[index] != 0)
    {
        // Pick random candidate and use recursion to fill board
        board[index] = pickRandCandidate(newPoss[index]);
        // update "adjacent" possibilities
        update(board[index], index, newPoss);
        if (solveRev(board, newPoss))
        {
            return true;
        }
    }
    // If a candidate doesn't work, use a different candidate
    // If no more candidates, unsolvable
    board[index] = 0; // revert
    return false;
}

/*
This variation of the solve function makes a copy of  both the board and
possibilities arrays.
*/
bool PuzzleGenerator::solveCop(const uint8_t board[Constants::SIZE], const uint16_t possibilities[Constants::SIZE])
{
    // Make new ones
    uint8_t newBoard[Constants::SIZE];
    uint16_t newPoss[Constants::SIZE];
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        newBoard[i] = board[i];
        newPoss[i] = possibilities[i];
    }

    // Pick empty cell with fewest candidates
    int index = getEmptyIndex(newBoard, newPoss);
    // no empty cells remaining means board is filled
    if (index == -1)
    {
        // Cool.
        for (int i = 0; i < Constants::SIZE; ++i)
        {
            this->board[i] = newBoard[i];
        }
        return true;
    }

    while (newPoss[index] != 0)
    {
        // Pick random candidate and use recursion to fill board
        newBoard[index] = pickRandCandidate(newPoss[index]);
        // update "adjacent" possibilities
        update(newBoard[index], index, newPoss);
        if (solveCop(newBoard, newPoss))
        {
            return true;
        }
    }
    // If a candidate doesn't work, use a different candidate
    // If no more candidates, unsolvable
    return false;
}

/*
This method initializes the board and possibilities arrays, depending on the
generator's type. It is called by generateNewPuzzle().
*/
void PuzzleGenerator::initializeBoards(uint8_t board[Constants::SIZE], uint16_t possibilities[Constants::SIZE])
{
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        board[i] = 0;
        possibilities[i] = Constants::INIT_P;
    }
    if (type > 1)
    {
        // special board start
        if (type == solverType::ONEROW)
        {
            // row
            generateRow(0, board, possibilities);
        }
        else
        {
            int n = 0;
            // [1,3] tiles
            if (type == solverType::ONETILE)
            {
                n = 1;
            }
            else if (type == solverType::TWOTILES)
            {
                n = 2;
            }
            else if (type == solverType::THREETILES)
            {
                n = 3;
            }
            for (int i = 0; i < n; ++i)
            {
                // indices 0, 30, 60
                // the tiles along the upper left to lower right diagonal
                generateTile(i * 30, board, possibilities);
            }
        }
    }
}

/*
This simply generates a row in the board without consideration of other existing
squares, only of its own row.
*/
void PuzzleGenerator::generateRow(int startIndex, uint8_t board[Constants::SIZE], uint16_t possibilities[Constants::SIZE])
{
    for (int i = startIndex; i < startIndex + 9; ++i)
    {
        board[i] = pickRandCandidate(possibilities[i]);
        update(board[i], i, possibilities);
    }
}

/*
This simply generates a 3x3 tile in the board without consideration of other
existing squares, only of its own tile.
*/
void PuzzleGenerator::generateTile(int startIndex, uint8_t board[Constants::SIZE], uint16_t possibilities[Constants::SIZE])
{
    for (int i = 0; i < 3; ++i)
    {
        int countStart = startIndex + (i * 9);
        for (int j = 0; j < 3; ++j)
        {
            int modIndex = countStart + j;
            board[modIndex] = pickRandCandidate(possibilities[modIndex]);
            update(board[modIndex], modIndex, possibilities);
        }
    }
}

/*
This function returns the index of an unassigned/empty square. It prioritizes
squares that have fewer options left.
Later on I added the ability to eject early if a square has only one choice
remaining. I'd already drawn data without that, so I will show the tables here.
|             NO EJECT             |
| Type      | Time     | % Success |
| Reversion |  5.61626 |     64.28 |
| Copy      |  5.56964 |     64.38 |
| 1 Row     |  1.95729 |     64.73 |
| 1 Tile    |  1.96565 |     63.88 |
| 2 Tiles   |  1.51837 |     73.48 |
| 3 Tiles   |  1.01578 |     76.37 |
+-----------+----------+-----------+
|            WITH EJECT            |
| Type      | Time [s] | % Success |
| Reversion | 4.443865 |     64.28 |
| Copy      | 4.484913 |     63.87 |
| 1 Row     | 1.592783 |     64.25 |
| 1 Tile    | 1.604688 |     64.14 |
| 2 Tiles   | 1.148189 |     76.79 |
| 3 Tiles   | 0.898682 |     76.26 |
*/
int PuzzleGenerator::getEmptyIndex(const uint8_t board[Constants::SIZE], const uint16_t possibilities[Constants::SIZE])
{
    int numCandidates = 10; // max number of candidates any entry can have is 9
    int index = -1;
    // linearly traverses through
    // might be faster if it saved the furthest consecutively-filled square
    // and started there instead of at zero
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        if (board[i] == 0) // only checking unfilled indices
        {
            int currentCandidates = countCandidates(i, possibilities);
            if (currentCandidates == 1) // Early eject revision
            {
                return i;
            }
            if (numCandidates > currentCandidates)
            {
                // this index has fewer candidates than the previous one
                index = i;
                numCandidates = currentCandidates;
            }
        }
    }
    // returns -1 if board lacks an empty space
    return index;
}

/*
Simply counts the number of candidates remaining in the square of possibilities.
*/
int PuzzleGenerator::countCandidates(int index, const uint16_t possibilities[Constants::SIZE])
{
    int total = 0;
    for (int i = 0; i < 9; ++i)
    {
        // just count the 1 bits
        int16_t check = 1 << i;
        if ((possibilities[index] & (check)) != 0)
        {
            ++total;
        }
    }
    return total;
}

/*
Randomly picks one of the candidates.
*/
uint8_t PuzzleGenerator::pickRandCandidate(const uint16_t candidates)
{
    // There is probably a better way to do this.
    uint8_t num = (rand() % 9); // [0,8]
    uint16_t index = 1 << num;
    while ((index & candidates) == 0)
    {
        // picks a random number until it gets a hit
        num = (rand() % 9);
        index = 1 << num;
    }
    return (num + 1); // don't forget [1,9]
}

/*
Simply returns a modified value that we can save in the board of possibilities.
*/
uint16_t PuzzleGenerator::removeCandidate(uint8_t candidate, uint16_t candidateSet)
{
    uint16_t check = 1 << (candidate - 1);
    check = ~check;
    
    return (candidateSet & check);
}

/*
This updates the board of possibilities according to the new value that has been
assigned to the actual board.
*/
void PuzzleGenerator::update(const uint8_t newValue, const int index, uint16_t possibilities[Constants::SIZE])
{
    // adjust its row
    int rowIndex = index / 9;
    rowIndex *= 9;
    for (int i = rowIndex; i < rowIndex + 9; ++i)
    {
        possibilities[i] = removeCandidate(newValue, possibilities[i]);
    }
    // fix its column
    int colIndex = index % 9;
    for (int i = colIndex; i < Constants::SIZE; i += 9)
    {
        possibilities[i] = removeCandidate(newValue, possibilities[i]);
    }
    // modify its tile
    int rowTile = (index / 9) / 3;
    int colTile = (index % 9) / 3;
    int tileIndex = (rowTile * 27) + (colTile * 3);
    for (int i = 0; i < 3; ++i)
    {
        int countStart = tileIndex + (i * 9);
        for (int j = 0; j < 3; ++j)
        {
            int modIndex = countStart + j;
            possibilities[modIndex] = removeCandidate(newValue, possibilities[modIndex]);
        }
    }
}

// GETTERS (essentially)
/*
Generates a string of the board in a sorta pretty format with gridlines.
*/
std::string PuzzleGenerator::puzzleToString()
{
    std::ostringstream sout;
    int bars = 2;
    sout << "\nBoard:\n";
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        sout << ((int) board[i]);

        if ((i + 1) % 9 == 0)
        {
            sout << "\n";
            if ((i + 1) % 27 == 0)
            {
                if (bars > 0)
                {
                    sout << "-----+-----+-----\n";
                    --bars;
                }
            }
        }
        else
        {
            if ((i + 1) % 3 == 0)
            {
                sout << "|";
            }
            else
            {
                sout << " ";
            }
        }
    }

    return sout.str();
}

/*
This returns a string of the type of solver that is being used.
*/
std::string PuzzleGenerator::getIdentifier()
{
    if (type == solverType::REVERT)
    {
        return "Reversion";
    }
    if (type == solverType::COPY)
    {
        return "Copy";
    }
    if (type == solverType::ONEROW)
    {
        return "ReversionRow";
    }
    if (type == solverType::ONETILE)
    {
        return "ReversionTile";
    }
    if (type == solverType::TWOTILES)
    {
        return "Reversion2Tile";
    }
    if (type == solverType::THREETILES)
    {
        return "Reversion3Tile";
    }
    return "Bad Construction";
}

// Functions used to help track and confirm success
/*
This directly writes the board to console.
*/
void PuzzleGenerator::write(const uint8_t board[Constants::SIZE])
{
    int bars = 2;
    std::cout << "\nBoard:\n";
    for (int i = 0; i < Constants::SIZE; ++i)
    {
        std::cout << ((int)board[i]);

        if ((i + 1) % 9 == 0)
        {
            std::cout << "\n";
            if ((i + 1) % 27 == 0)
            {
                if (bars > 0)
                {
                    std::cout << "-----+-----+-----\n";
                    --bars;
                }
            }
        }
        else
        {
            if ((i + 1) % 3 == 0)
            {
                std::cout << "|";
            }
            else
            {
                std::cout << " ";
            }
        }
    }
    std::cout << "\n";
}

/*
This just checks to make sure the puzzle is properly filled according to Sudoku
guidelines.
*/
bool PuzzleGenerator::doubleCheck()
{
    // check rows
    for (int i = 0; i < 9; ++i) // rows [0,8]
    {
        uint16_t rowCheck = Constants::INIT_P;
        for (int j = 0; j < 9; ++j)
        {
            int index = (i * 9) + j;
            uint16_t value = 1 << (board[index] - 1);
            if ((value & rowCheck) == value)
            {
                // can continue
                rowCheck = rowCheck ^ value;
            }
            else
            {
                std::cout << " Row Error at index " << index << std::endl;
                return false;
            }
        }
    }
    // check cols
    for (int i = 0; i < 9; ++i)
    {
        uint16_t colCheck = Constants::INIT_P;
        for (int j = i; j < Constants::SIZE; j += 9)
        {
            uint16_t value = 1 << (board[j] - 1);
            if ((value & colCheck) == value)
            {
                // continue
                colCheck = colCheck ^ value;
            }
            else
            {
                std::cout << " Col Error at index " << j << std::endl;
                return false;
            }
        }
    }
    // check tiles
    for (int rowSet = 0; rowSet < 3; ++rowSet)
    {
        for (int colSet = 0; colSet < 3; ++colSet)
        {
            int startIndex = (rowSet * 27) + (colSet * 3);
            uint16_t tileCheck = Constants::INIT_P;

            for (int i = 0; i < 3; ++i)
            {
                int countStart = startIndex + (i * 9);
                for (int j = 0; j < 3; ++j)
                {
                    int index = countStart + j;
                    uint16_t value = 1 << (board[index] - 1);
                    if ((value & tileCheck) == value)
                    {
                        // continue
                        tileCheck = tileCheck ^ value;
                    }
                    else
                    {
                        std::cout << " Tile Error at index " << index << std::endl;
                        return false;
                    }
                }
            }
        }
    }

    std::cout << "RCT" << std::endl;
    return true;
}